// COPYRIGHT Dassault Systemes 2006
//===================================================================
//
// CLog.cpp
// Header definition of CLog
//
//===================================================================
//
// Usage notes:
//
//===================================================================
//
//  Mar 2006  Creation: Code generated by the CAA wizard  ev5adm
//===================================================================
#include "CLog.h"
#include <iostream.h>
#include "CHandleString.h"

CATImplementClass( CLog,
				  Implementation, 
				  CATBaseUnknown,
				  CATNull );

//-----------------------------------------------------------------------------
// CLog : constructor
//-----------------------------------------------------------------------------
CLog::CLog():
CATBaseUnknown()
{
}

//-----------------------------------------------------------------------------
// CLog : destructor
//-----------------------------------------------------------------------------
CLog::~CLog()
{
}

//-----------------------------------------------------------------------------
// CLog : copy constructor
//-----------------------------------------------------------------------------
CLog::CLog(CLog& original):
CATBaseUnknown(original)
{
}

//-----------------------------------------------------------------------------
// CLog : equal operator
//-----------------------------------------------------------------------------
CLog& CLog::operator=(CLog& original)
{
	CATBaseUnknown::operator=(original);
	return *this;
}

HRESULT CLog::InitLog(char* path)
{
	if(!strlen(path)) return E_FAIL;

	logFilePath = path;
	initialLogFilePath = logFilePath;

	//判断日志级别
	CATUnicodeString configLogLevel = "DEBUG";
	if (configLogLevel == "DEBUG") logLevel = 1;
	else if (configLogLevel == "INFO") logLevel = 2;
	else if (configLogLevel == "WARN") logLevel = 3;
	else if (configLogLevel == "ERROR") logLevel = 4;
	else if (configLogLevel == "FATAL") logLevel = 5;
	else logLevel = 1;

	char tmp[256] ;
	CHandleString::myGetTime( tmp ) ;
	strcat( tmp , "----------------------\n") ;

	WriteLog(" --------------------------------------------------------------------\n") ;
	WriteLog(" --------------------------------------------------------------------\n") ;
	WriteLog(" ---------------------------Data Check LOG-----------------------\n") ;
	WriteLog(" ---------------------------Date : ") ;
	WriteLog(tmp) ;
	WriteLog(" --------------------------------------------------------------------\n") ;

	return S_OK;	
}

//同时把日志输出到文本和控制台
HRESULT CLog::WriteLog(const char* msg)
{
	//if(InitPara0::retPara("LCAIXP_DEBUG") == "YES") 
		cout << msg << flush;

	if(logFilePath == "") return E_FAIL;

	logFile = NULL ;
	logFile = fopen(logFilePath, "at+");
	if (logFile == NULL) 
	{ 
		cout << "   Cannot Open log file " << endl ;
		return E_FAIL;
	}

	fputs(msg , logFile) ;
	fclose(logFile);

	lineCounter++;
	if(lineCounter == 100000)
	{
		//切换日志文件
		fileCounter++;

		char newFilePath[256];
		sprintf(newFilePath,"%s.%d",initialLogFilePath.ConvertToChar(),fileCounter);
		logFilePath = newFilePath;

		lineCounter = 0;
	}

	return S_OK;
}

HRESULT CLog::WriteLog(const char* msg, unsigned int outLevel)
{
	//假如需要记录的日志级别不够系统配置的级别，不输出
	if(outLevel < logLevel) return E_FAIL;

	char strLevel[20] = "";
	if(outLevel == 1) strcpy(strLevel," 调试 ");
	else if(outLevel == 2) strcpy(strLevel," 信息 ");
	else if(outLevel == 3) strcpy(strLevel," 警告 ");
	else if(outLevel == 4) strcpy(strLevel," 错误 ");
	else if(outLevel == 5) strcpy(strLevel," 致命 ");
	else strcpy(strLevel,"");

	char tmp[256] ;
	CHandleString::myGetTime( tmp ) ;
	strcat( tmp , strLevel) ;
	strcat( tmp, msg);
	strcat( tmp, "\n");

	return WriteLog(tmp);
}

HRESULT CLog::WriteLog(const CATUnicodeString msg, unsigned int outLevel)
{
	return WriteLog(msg.ConvertToChar(),outLevel);
}

HRESULT CLog::Debug(const CATUnicodeString msg)
{
	return S_OK;
	return WriteLog(msg.ConvertToChar(),1);
}

HRESULT CLog::Debug(const char* msg)
{
	return S_OK;
	return WriteLog(msg,1);
}

HRESULT CLog::Info(const CATUnicodeString msg)
{	
	return WriteLog(msg.ConvertToChar(),2);
}

HRESULT CLog::Info(const char* msg)
{	
	return WriteLog(msg,2);
}

HRESULT CLog::Warn(const CATUnicodeString msg)
{
	return WriteLog(msg.ConvertToChar(),3);
}

HRESULT CLog::Warn(const char* msg)
{
	return WriteLog(msg,3);
}

HRESULT CLog::Error(const CATUnicodeString msg)
{
	return WriteLog(msg.ConvertToChar(),4);
}

HRESULT CLog::Error(const char* msg)
{
	return WriteLog(msg,4);
}

HRESULT CLog::Fatal(const CATUnicodeString msg)
{
	return WriteLog(msg.ConvertToChar(),5);
}

HRESULT CLog::Fatal(const char* msg)
{
	return WriteLog(msg,5);
}


FILE*   CLog::logFile ;
unsigned int CLog::logLevel = 0;
CATUnicodeString CLog::logFilePath;
CATUnicodeString CLog::initialLogFilePath;
long CLog::fileCounter = 0;
long CLog::lineCounter = 0;
