// COPYRIGHT Dassault Systemes 2011
//===================================================================
//
// PrtFstPointsCmd.cpp
// The state chart based command: PrtFstPointsCmd
//
//===================================================================
//
// Usage notes:
//
//===================================================================
//
//  Nov 2011  Creation: Code generated by the CAA wizard  Administrator
//===================================================================
#include "PrtFstPointsCmd.h"
#include "CATIndicationAgent.h"
#include "CATMathPlane.h"

#include "CATCreateExternalObject.h"
CATCreateClass( PrtFstPointsCmd);

#include "iostream"
using namespace std;

#include "CATLine.h"
#include "CATSurface.h"
#include "CATIMfBiDimResult.h"
#include "CATIMfMonoDimResult.h"
#include "CATCurve.h"
#include "PrtService.h"
#include "CATIMfBRep.h"
#include "CATIGSMAssemble.h"
#include "CATIGSMCurvePar.h"
#include "CATIMeasurableCurve.h"
#include "CATIGSMExtremum.h"
#include "CATAcquisitionFilter.h"



//-------------------------------------------------------------------------
// Constructor
//-------------------------------------------------------------------------
PrtFstPointsCmd::PrtFstPointsCmd() :
  CATStateCommand ("PrtFstPointsCmd", CATDlgEngOneShot, CATCommandModeShared) 
//  Valid states are CATDlgEngOneShot and CATDlgEngRepeat
  ,m_pDlg(NULL),m_pRepeatPanelDlg(NULL),m_pCurveAgt(NULL),m_pSurfAgt(NULL),m_pCurveSLAgt(NULL),m_pSurfSLAgt(NULL),m_piPrdAgt(NULL),m_piPrdSLAgt(NULL)
  ,m_SpecSurfs(NULL_var),m_piDoc(NULL),m_spPointGSMTool(NULL_var),m_spCurvePar(NULL_var)
  ,m_dCurveOffsetValue(0),m_dPointsCount(0),m_dPointDistance(0),m_dType(1),m_spAssambleCurve(NULL_var),m_spRefPoint(NULL_var)
{
	//初始化获得当前文档及名称
	m_piDoc = PrtService::GetPrtDocument();
	PrtService::GetPrdNumberFormDoc(m_piDoc,m_strDocName);

	//判断是否为ZP模型;
	if ((!IsThisZPPrt(m_strDocName))||(!PrdService::IsContextualPrd()))
	{
		PrtService::ShowDlgNotify("提示","该功能仅在装配上下文环境且ZP模型中操作，点击关闭！");
		RequestDelayedDestruction();
	}
}

//判断是否为ZP模型
BOOL PrtFstPointsCmd::IsThisZPPrt(CATUnicodeString istrDocName)
{
	  if (istrDocName != "")
	  {
		  int istart=istrDocName.SearchSubString("-ZP",0,CATUnicodeString::CATSearchModeBackward);
		  if (istart != -1)
		  {
			  return TRUE;
		  }
		  else return FALSE;
	  }
	  else return FALSE;
}

//-------------------------------------------------------------------------
// Destructor
//-------------------------------------------------------------------------
PrtFstPointsCmd::~PrtFstPointsCmd()
{
	if (NULL!=m_pDlg)
	{
		m_pDlg->RequestDelayedDestruction();
		m_pDlg=NULL;
	}

	if (NULL!=m_pRepeatPanelDlg)
	{
		m_pRepeatPanelDlg->RequestDelayedDestruction();
		m_pRepeatPanelDlg=NULL;
	}
	
	if (NULL!=m_pCurveAgt)
	{
		m_pCurveAgt->RequestDelayedDestruction();
		m_pCurveAgt=NULL;
	}

	if (NULL!=m_pSurfAgt)
	{
		m_pSurfAgt->RequestDelayedDestruction();
		m_pSurfAgt=NULL;
	}

	if (NULL!=m_pCurveSLAgt)
	{
		m_pCurveSLAgt->RequestDelayedDestruction();
		m_pCurveSLAgt=NULL;
	}

	if (NULL!=m_pSurfSLAgt)
	{
		m_pSurfSLAgt->RequestDelayedDestruction();
		m_pSurfSLAgt=NULL;
	}

	if (NULL!=m_piPrdSLAgt)
	{
		m_piPrdSLAgt->RequestDelayedDestruction();
		m_piPrdSLAgt=NULL;
	}

	if (NULL!=m_piPrdAgt)
	{
		m_piPrdAgt->RequestDelayedDestruction();
		m_piPrdAgt=NULL;
	}
}


//-------------------------------------------------------------------------
// BuildGraph()
//-------------------------------------------------------------------------
void PrtFstPointsCmd::BuildGraph()
{
	//
	m_pDlg = new PrtFstPointsDlg();
	m_pDlg->Build();
	m_pDlg->SetVisibility(CATDlgShow); 
	
	//
	m_pRepeatPanelDlg = new PrtFstPointRepeatPanelDlg();
	m_pRepeatPanelDlg->Build();
	m_pRepeatPanelDlg->SetVisibility(CATDlgShow);

	// 主对话框的消息响应
	AddAnalyseNotificationCB (m_pDlg, 
		m_pDlg->GetDiaOKNotification(),
		(CATCommandMethod)&PrtFstPointsCmd::OkDlgCB,
		NULL);

	AddAnalyseNotificationCB (m_pDlg, 
		m_pDlg->GetWindCloseNotification(),
		(CATCommandMethod)&PrtFstPointsCmd::CloseDlgCB,
		NULL);

	AddAnalyseNotificationCB (m_pDlg, 
		m_pDlg->GetDiaCANCELNotification(),
		(CATCommandMethod)&PrtFstPointsCmd::CloseDlgCB,
		NULL);

	AddAnalyseNotificationCB (m_pDlg, 
		m_pDlg->GetDiaPREVIEWNotification(),
		(CATCommandMethod)&PrtFstPointsCmd::OnPREVIEWCB,
		NULL);


	// 安装线偏移反向按钮响应
	AddAnalyseNotificationCB (m_pDlg->_ReverseDirePB, 
		m_pDlg->_ReverseDirePB->GetPushBActivateNotification(),
		(CATCommandMethod)&PrtFstPointsCmd::OnReverseOffsetDirePBCB,
		NULL);
	// 参考极值点转换按钮响应
	AddAnalyseNotificationCB (m_pDlg->_ExtremityPB, 
		m_pDlg->_ExtremityPB->GetPushBActivateNotification(),
		(CATCommandMethod)&PrtFstPointsCmd::OnRefPointExtremityPBCB,
		NULL);
	// 参考中心点转换按钮响应
	AddAnalyseNotificationCB (m_pDlg->_MiddlePB, 
		m_pDlg->_MiddlePB->GetPushBActivateNotification(),
		(CATCommandMethod)&PrtFstPointsCmd::OnRefPointMiddlePBCB,
		NULL);
	// 参考点距离模式下反向按钮响应
	AddAnalyseNotificationCB (m_pDlg->_DisToRefInvertPushB, 
		m_pDlg->_DisToRefInvertPushB->GetPushBActivateNotification(),
		(CATCommandMethod)&PrtFstPointsCmd::OnDisToRefInvertPBCB,
		NULL);
	//Ref End Point反向按钮响应
	AddAnalyseNotificationCB (m_pRepeatPanelDlg->_ExtremityPB, 
		m_pRepeatPanelDlg->_ExtremityPB->GetPushBActivateNotification(),
		(CATCommandMethod)&PrtFstPointsCmd::OnRefEndPointExtremityPBCB,
		NULL);

	// 曲线偏移距离调整响应
	AddAnalyseNotificationCB (m_pDlg->_DistanceSpinner, 
		m_pDlg->_DistanceSpinner->GetSpinnerModifyNotification(),
		(CATCommandMethod)&PrtFstPointsCmd::OnOffsetDistanceSpinnerCB,
		NULL);
	//Distance To Ref Point调整响应
	AddAnalyseNotificationCB (m_pDlg->_DisToRefSpinner, 
		m_pDlg->_DisToRefSpinner->GetSpinnerModifyNotification(),
		(CATCommandMethod)&PrtFstPointsCmd::OnDisToRefSpinnerCB,
		NULL);

	//
	//创建prd代理
	m_piPrdAgt = new CATPathElementAgent("选择连接零件");
	m_piPrdAgt -> SetBehavior( CATDlgEngWithPrevaluation | CATDlgEngWithPSOHSO | CATDlgEngRepeat  );
	m_piPrdAgt -> AddElementType (IID_CATIProduct);
	CATAcquisitionFilter * pFilterForPrt = Filter((FilterMethod) & PrtFstPointsCmd::SeletedIsPart,(void*)NULL);
	m_piPrdAgt->SetFilter(pFilterForPrt);

	//创建边线代理
	m_pCurveAgt = new CATFeatureImportAgent("选择边线");
	m_pCurveAgt -> SetBehavior( CATDlgEngWithPrevaluation | CATDlgEngWithPSO | CATDlgEngRepeat );
	m_pCurveAgt -> SetAgentBehavior( MfPermanentBody | MfLastFeatureSupport | MfRelimitedFeaturization);
	m_pCurveAgt -> AddElementType (IID_CATIMfMonoDimResult);
	m_pCurveAgt -> AddElementType (IID_CATCurve);

	//创建安装面代理
	m_pSurfAgt = new CATFeatureImportAgent("选择安装面");
	m_pSurfAgt -> SetBehavior( CATDlgEngWithPrevaluation | CATDlgEngWithPSO | CATDlgEngRepeat );
	m_pSurfAgt -> SetAgentBehavior( MfPermanentBody | MfLastFeatureSupport | MfRelimitedFeaturization);
	m_pSurfAgt -> AddElementType (IID_CATIMfBiDimResult);
	m_pSurfAgt -> AddElementType (IID_CATSurface);

	//Surf SL
	m_piPrdSLAgt = new CATDialogAgent("选择连接零件SL");
	m_piPrdSLAgt->SetBehavior(CATDlgEngRepeat);
	m_piPrdSLAgt->AcceptOnNotify(m_pDlg->_ContextSelectorList,m_pDlg->_ContextSelectorList->GetListSelectNotification());

	//Curve SL
	m_pCurveSLAgt = new CATDialogAgent("选择边线SL");
	m_pCurveSLAgt->SetBehavior(CATDlgEngRepeat);
	m_pCurveSLAgt->AcceptOnNotify(m_pDlg->_CurveSL,m_pDlg->_CurveSL->GetListSelectNotification());

	//Surf SL
	m_pSurfSLAgt = new CATDialogAgent("选择安装面SL");
	m_pSurfSLAgt->SetBehavior(CATDlgEngRepeat);
	m_pSurfSLAgt->AcceptOnNotify(m_pDlg->_SurfSL,m_pDlg->_SurfSL->GetListSelectNotification());


	//Define the StateChart
	CATDialogState * StSelectPrds = GetInitialState("选择连接零件");
	StSelectPrds -> AddDialogAgent (m_piPrdAgt);
	StSelectPrds -> AddDialogAgent (m_piPrdSLAgt);
	StSelectPrds -> AddDialogAgent (m_pCurveSLAgt);
	StSelectPrds -> AddDialogAgent (m_pSurfSLAgt);	

	CATDialogState * StSelectCurve = AddDialogState("选择边线");
	StSelectCurve -> AddDialogAgent (m_pCurveAgt);
	StSelectCurve -> AddDialogAgent (m_pCurveSLAgt);
	StSelectCurve -> AddDialogAgent (m_pSurfSLAgt);
	StSelectCurve -> AddDialogAgent (m_piPrdSLAgt);

	CATDialogState * StSelectSurf = AddDialogState("选择安装面");
	StSelectSurf -> AddDialogAgent (m_pSurfAgt);
	StSelectSurf -> AddDialogAgent (m_pCurveSLAgt);
	StSelectSurf -> AddDialogAgent (m_pSurfSLAgt);
	StSelectSurf -> AddDialogAgent (m_piPrdSLAgt);

	//转换关系 Prd Prd
	AddTransition(StSelectPrds,StSelectPrds,
		IsLastModifiedAgentCondition(m_piPrdAgt),
		Action ((ActionMethod) &PrtFstPointsCmd::ChoosePrds));
	//转换关系 Prd PrdSL
	AddTransition(StSelectPrds,StSelectPrds,
		IsLastModifiedAgentCondition(m_piPrdSLAgt),
		Action ((ActionMethod) &PrtFstPointsCmd::ActivePrdSL));
	//转换关系 Prd 线SL
	AddTransition(StSelectPrds,StSelectCurve,
		IsLastModifiedAgentCondition(m_pCurveSLAgt),
		Action ((ActionMethod) &PrtFstPointsCmd::ActiveCurveSL));
	//转换关系 Prd 面SL
	AddTransition(StSelectPrds,StSelectSurf,
		IsLastModifiedAgentCondition(m_pSurfSLAgt),
		Action ((ActionMethod) &PrtFstPointsCmd::ActiveSurfSL));

	//转换关系 线到线
	AddTransition(StSelectCurve, StSelectCurve, 
		IsLastModifiedAgentCondition(m_pCurveAgt),
		Action ((ActionMethod) &PrtFstPointsCmd::ChooseCurve));
	//转换关系 线到线SL
	AddTransition(StSelectCurve, StSelectCurve, 
		IsLastModifiedAgentCondition(m_pCurveSLAgt),
		Action ((ActionMethod) &PrtFstPointsCmd::ActiveCurveSL));
	//转换关系 线到PrdSL
	AddTransition(StSelectCurve, StSelectPrds, 
		IsLastModifiedAgentCondition(m_piPrdSLAgt),
		Action ((ActionMethod) &PrtFstPointsCmd::ActivePrdSL));
	//转换关系 线到面SL
	AddTransition(StSelectCurve, StSelectSurf, 
		IsLastModifiedAgentCondition(m_pSurfSLAgt),
		Action ((ActionMethod) &PrtFstPointsCmd::ActiveSurfSL));


	//转换关系 面到面
	AddTransition(StSelectSurf, StSelectSurf, 
		IsLastModifiedAgentCondition(m_pSurfAgt),
		Action ((ActionMethod) &PrtFstPointsCmd::ChooseSurf));
	//转换关系 面到面SL
	AddTransition(StSelectSurf, StSelectSurf, 
		IsLastModifiedAgentCondition(m_pSurfSLAgt),
		Action ((ActionMethod) &PrtFstPointsCmd::ActiveSurfSL));
	//转换关系 面到线SL
	AddTransition(StSelectSurf, StSelectCurve, 
		IsLastModifiedAgentCondition(m_pCurveSLAgt),
		Action ((ActionMethod) &PrtFstPointsCmd::ActiveCurveSL));
	//转换关系 面到PrdSL
	AddTransition(StSelectSurf, StSelectPrds, 
		IsLastModifiedAgentCondition(m_piPrdSLAgt),
		Action ((ActionMethod) &PrtFstPointsCmd::ActivePrdSL));
	
	
}

CATBoolean PrtFstPointsCmd::SeletedIsPart(CATDialogAgent * iAgent, void * iUsefulData)
{
	CATBoolean rc = FALSE ;
	if ( NULL == iAgent ) return rc ;

	CATBaseUnknown* piSelectElement =m_piPrdAgt->GetElementValue();//获得所选对象
	if (piSelectElement != NULL)
	{
		CATIProduct_var spPrd = NULL_var;
		spPrd = piSelectElement;

		CATUnicodeString strDocType("");
		PrdService::GetInstPrdType(spPrd,strDocType);

		if (strDocType == "CATPart")
		{
			return TRUE;
		}
	}

	return rc;
}


CATBoolean PrtFstPointsCmd::ActivePrdSL( void *UsefulData)
{
	m_pDlg->_SurfSL->ClearSelect();
	m_pDlg->_CurveSL->ClearSelect();

	//清除高亮
	PrtService::ClearHSO();
	//加入需要高亮的特征
	ShowSeletedLine(m_pDlg->_ContextSelectorList,m_lstSpecPrds);

	m_piPrdAgt->InitializeAcquisition();
	return TRUE;
}

//高亮显示当前所选行
void PrtFstPointsCmd::ShowSeletedLine(CATDlgSelectorList* opiSL,CATListValCATISpecObject_var olstSpecs)
{
	//如果为空，直接退出
	if (olstSpecs.Size() == 0)
	{
		return;
	}
	//获取所选行
	int NumberOfRowsSelected;
	NumberOfRowsSelected = opiSL->GetSelectCount();

	int *iSelectedRows = new int[NumberOfRowsSelected];
	opiSL->GetSelect(iSelectedRows,NumberOfRowsSelected);

	//重新添加高亮
	for (int i = 0; i < NumberOfRowsSelected; i ++)
	{
		PrtService::HighlightHSO(olstSpecs[iSelectedRows[i]+1]);
	}
}

//转变OK APPLY按钮的显示状态
void PrtFstPointsCmd::ChangeOKApplyState()
{
	//控制APPLY&OK状态
	if (m_lstSpecCurves.Size()!=0 && m_lstSpecPrds.Size()!=0 && m_SpecSurfs!=NULL_var)
	{
		m_pDlg->SetOKSensitivity(CATDlgEnable);
		m_pDlg->SetPREVIEWSensitivity(CATDlgEnable);
	}
	else
	{
		m_pDlg->SetOKSensitivity(CATDlgDisable);
		m_pDlg->SetPREVIEWSensitivity(CATDlgDisable);
	}
}

//消息框响应函数
void PrtFstPointsCmd::OkDlgCB(CATCommand* cmd, CATNotification* evt, CATCommandClientData data)
{
	CreatePoints();
	RequestDelayedDestruction();
}
void PrtFstPointsCmd::CloseDlgCB(CATCommand* cmd, CATNotification* evt, CATCommandClientData data)
{
	//隐藏线
	for (int i = 1; i <= m_lstSpecCurves.Size(); i++)
	{
		PrtService::SetSpecObjShowAttr(m_lstSpecCurves[i],"Hide");
	}

	//隐藏面
	PrtService::SetSpecObjShowAttr(m_SpecSurfs,"Hide");

	//删除几何图形集
	if (m_spPointGSMTool!=NULL_var)
	{
		m_spPointGSMTool->GetFather()->Remove(m_spPointGSMTool);
	}

	RequestDelayedDestruction();
}

//
//响应
CATBoolean PrtFstPointsCmd::ChoosePrds( void *UsefulData)
{
	HRESULT hr = E_FAIL;

	CATPathElement* piSelectElement =m_piPrdAgt->GetValue();//获得所选对象
	if (piSelectElement != NULL)
	{
		//获得SUB PATH
		CATBaseUnknown * pLeaf =NULL ;
		//获得路径下第一个特征spec类型
		pLeaf = (*piSelectElement)[piSelectElement->GetSize()-1];
		CATISpecObject_var spSpecOnSelection = NULL_var;
		spSpecOnSelection = pLeaf;

		if ( spSpecOnSelection != NULL_var )
		{
			CATBoolean existFlag = FALSE;
			for (int i = 1; i <= m_lstSpecPrds.Size(); i ++)
			{
				if (m_lstSpecPrds[i] == spSpecOnSelection)
				{
					m_lstSpecPrds.RemoveValue(spSpecOnSelection);
					existFlag = TRUE;
					break;
				}
			}

			if (existFlag == FALSE)
			{
				CATDocument* opiPrdDoc = NULL;
				PrdService::GetInstPrdDoc(spSpecOnSelection,opiPrdDoc);
				CATUnicodeString strPrdName;
				PrtService::GetPrdNumberFormDoc(opiPrdDoc,strPrdName);

				if (IsThisZPPrt(strPrdName))
				{
					PrtService::ktWarningMsgBox("不能选择ZP模型为安装零件，请重新选择！");
					PrtService::RemoveHSO(spSpecOnSelection);
				}
				else
					m_lstSpecPrds.Append(spSpecOnSelection);				
			}

			m_pDlg->_ContextSelectorList->ClearLine();
			for (int i = 1; i <= m_lstSpecPrds.Size(); i ++)
			{
				//
				CATUnicodeString strShowPath("");
				CATPathElement *piPath = NULL;
				PrtService::GetPathElementFromSpecObject(piPath,m_lstSpecPrds[i],NULL);
				PrtService::PathElementString(piPath,strShowPath,TRUE);
				m_pDlg->_ContextSelectorList->SetLine(strShowPath);

				piPath->Release();
				piPath=NULL;
			}

			if (m_lstSpecPrds.Size()==0)
			{
				m_pDlg->_ContextSelectorList->SetLine("请选择连接零件");
			}
		}
	}

	//
	m_pDlg->_SurfSL->ClearSelect();
	m_pDlg->_CurveSL->ClearSelect();

	//
	PrtService::ClearHSO();
	PrtService::HighLightObjLst(m_lstSpecPrds);

	//
	ChangeOKApplyState();
	m_piPrdAgt->InitializeAcquisition();
	return TRUE;	
}

//
CATBoolean PrtFstPointsCmd::ChooseCurve( void *UsefulData)
{
	HRESULT hr = E_FAIL;

	CATBaseUnknown* piSelectElement =m_pCurveAgt->GetElementValue();//获得所选对象
	if (piSelectElement != NULL)
	{
		//获得SUB PATH
		CATIMfBRep *piBrep = NULL;
		hr = piSelectElement->QueryInterface(IID_CATIMfBRep,(void**)&piBrep);
		//
		CATISpecObject_var spSpecOnSelection =NULL_var;
		if (SUCCEEDED(hr)&&(piBrep!=NULL))
		{
			spSpecOnSelection = piBrep->GetSupport();
			piBrep->Release();
			piBrep=NULL;
		}
		else
		{
			spSpecOnSelection = piSelectElement;
		}

		//根据情况判断
		if ( spSpecOnSelection != NULL_var )
		{
			CATBoolean existFlag = FALSE;
			for (int i = 1; i <= m_lstSpecCurves.Size(); i ++)
			{
				if (m_lstSpecCurves[i] == spSpecOnSelection)
				{
					m_lstSpecCurves.RemoveValue(spSpecOnSelection);
					PrtService::SetSpecObjShowAttr(spSpecOnSelection,"Hide");
					PrtService::RemoveHSO(spSpecOnSelection);
					existFlag = TRUE;
					break;
				}
			}

			if (existFlag == FALSE)
			{		
				PrtService::SetSpecObjShowAttr(spSpecOnSelection,"Show");
				m_lstSpecCurves.Append(spSpecOnSelection);
				PrtService::HighlightHSO(spSpecOnSelection);				
			}

			if (m_lstSpecCurves.Size()>=1)
			{
				CATUnicodeString strLineShow("共选择");
				CATUnicodeString strNumber;
				strNumber.BuildFromNum(m_lstSpecCurves.Size());
				strLineShow += strNumber + "个线";
				m_pDlg->_CurveSL->SetLine(strLineShow,0,CATDlgDataModify);
			}
			if (m_lstSpecCurves.Size()==0)
			{
				m_pDlg->_CurveSL->SetLine("No Selection",0,CATDlgDataModify);
			}
		}
	}

	//
	m_pDlg->_SurfSL->ClearSelect();
	
	//
	ChangeOKApplyState();
	m_pCurveAgt->InitializeAcquisition();
	return TRUE;
}

CATBoolean PrtFstPointsCmd::ChooseSurf( void *UsefulData)
{
	HRESULT hr = E_FAIL;

	CATBaseUnknown* piSelectElement =m_pSurfAgt->GetElementValue();//获得所选对象
	if (piSelectElement != NULL)
	{
		//获得SUB PATH
		CATIMfBRep *piBrep = NULL;
		hr = piSelectElement->QueryInterface(IID_CATIMfBRep,(void**)&piBrep);
		//
		CATISpecObject_var spSpecOnSelection =NULL_var;
		if (SUCCEEDED(hr)&&(piBrep!=NULL))
		{
			spSpecOnSelection = piBrep->GetSupport();
			piBrep->Release();
			piBrep=NULL;
		}
		else
		{
			spSpecOnSelection = piSelectElement;
		}

		//根据情况判断
		if ( spSpecOnSelection != NULL_var )
		{
			if (m_SpecSurfs == spSpecOnSelection)
			{
				PrtService::SetSpecObjShowAttr(spSpecOnSelection,"Hide");
				PrtService::RemoveHSO(spSpecOnSelection);
				m_pDlg->_SurfSL->SetLine("No Selection",0,CATDlgDataModify);
				m_SpecSurfs = NULL_var;
			}	
			else
			{	
				PrtService::SetSpecObjShowAttr(m_SpecSurfs,"Hide");
				PrtService::RemoveHSO(m_SpecSurfs);
				PrtService::SetSpecObjShowAttr(spSpecOnSelection,"Show");
				PrtService::HighlightHSO(spSpecOnSelection);
				m_SpecSurfs = spSpecOnSelection;
				//
				CATUnicodeString strShowPath("");
				CATPathElement *piPath = NULL;
				PrtService::GetPathElementFromSpecObject(piPath,spSpecOnSelection,NULL);
				PrtService::PathElementString(piPath,strShowPath,TRUE);
				m_pDlg->_SurfSL->SetLine(strShowPath,0,CATDlgDataModify);

				piPath->Release();
				piPath=NULL;
			}
		}
	}

	//
	m_pDlg->_CurveSL->ClearSelect();

	//
	ChangeOKApplyState();
	m_pSurfAgt->InitializeAcquisition();
	return TRUE;
}
//
CATBoolean PrtFstPointsCmd::ActiveCurveSL( void *UsefulData)
{
	//高亮所选线
	PrtService::ClearHSO();
	PrtService::HighLightObjLst(m_lstSpecCurves);

	//
	m_pDlg->_SurfSL->ClearSelect();
	m_pDlg->_ContextSelectorList->ClearSelect();

	m_pCurveAgt->InitializeAcquisition();
	return TRUE;
}
CATBoolean PrtFstPointsCmd::ActiveSurfSL( void *UsefulData)
{
	//高亮所选面
	PrtService::ClearHSO();
	PrtService::HighlightHSO(m_SpecSurfs);

	//
	m_pDlg->_CurveSL->ClearSelect();
	m_pDlg->_ContextSelectorList->ClearSelect();

	m_pSurfAgt->InitializeAcquisition();
	return TRUE;
}

void PrtFstPointsCmd::OnPREVIEWCB(CATCommand* cmd, CATNotification* evt, CATCommandClientData data)
{
	CreatePoints();	
}

//安装线偏移反向按钮响应
void PrtFstPointsCmd::OnReverseOffsetDirePBCB(CATCommand* cmd, CATNotification* evt, CATCommandClientData data)
{
	//
	if (m_spCurvePar!=NULL_var)
	{
		CATBoolean bDireState;
		CATIGSMCurvePar_var spGSMPar = m_spCurvePar;
		spGSMPar->GetInvertDirection(bDireState);
		//
		if (bDireState == FALSE)
		{
			//
			spGSMPar->SetInvertDirection(TRUE);
			//
			HRESULT rc = PrtService::ObjectUpdate(m_spCurvePar);
			if (FAILED(rc))
			{
				PrtService::ShowDlgNotify("错误提示","反向更新错误，将保持原方向");
				//
				spGSMPar->SetInvertDirection(FALSE);				
			}
		} 
		else
		{
			//
			spGSMPar->SetInvertDirection(FALSE);
			//
			HRESULT rc = PrtService::ObjectUpdate(m_spCurvePar);
			if (FAILED(rc))
			{
				PrtService::ShowDlgNotify("错误提示","反向更新错误，将保持原方向");
				//
				spGSMPar->SetInvertDirection(TRUE);				
			}
		}

		//
		PrtService::ObjectUpdate(m_spPointGSMTool);
	}
	//
}

//参考极值点转换按钮响应
void PrtFstPointsCmd::OnRefPointExtremityPBCB(CATCommand* cmd, CATNotification* evt, CATCommandClientData data)
{

}
//参考中心点转换按钮响应
void PrtFstPointsCmd::OnRefPointMiddlePBCB(CATCommand* cmd, CATNotification* evt, CATCommandClientData data)
{

}
//参考点距离模式下反向按钮响应
void PrtFstPointsCmd::OnDisToRefInvertPBCB(CATCommand* cmd, CATNotification* evt, CATCommandClientData data)
{

}
//Ref End Point反向按钮响应
void PrtFstPointsCmd::OnRefEndPointExtremityPBCB(CATCommand* cmd, CATNotification* evt, CATCommandClientData data)
{

}

//曲线偏移距离调整响应
void PrtFstPointsCmd::OnOffsetDistanceSpinnerCB(CATCommand* cmd, CATNotification* evt, CATCommandClientData data)
{

}

//Distance To Ref Point调整响应
void PrtFstPointsCmd::OnDisToRefSpinnerCB(CATCommand* cmd, CATNotification* evt, CATCommandClientData data)
{

}

// [3/8/2013 WZ4]
// 创建第一点函数，用于以后的循环创建模式
HRESULT PrtFstPointsCmd::CreateFastenerPoint(CATISpecObject_var ispInputCirve,double idOffetValue,double idLengthToRefPoint)
{
	//
	HRESULT rc = S_OK;
	//
	//创建偏移线
	double dOffsetValue = m_pDlg->_DistanceSpinner->GetValue();
	dOffsetValue *= 1000.0;
	//	
	//获得文档指针
	CATIGSMFactory_var iospGSMFact = NULL_var;
	PrtService::GetGSMFactory(m_piDoc,iospGSMFact);

	//创建几何图形集
	CATISpecObject_var ospFatGSSpecObj = NULL_var;
	PrtService::ObtainGSMTool(m_piDoc,"过程元素",ospFatGSSpecObj);
	CATIPrtContainer *opiRootContainer = NULL;
	PrtService::ObtainRootContainer(m_piDoc,opiRootContainer);
	//获得part
	CATISpecObject_var spPart = opiRootContainer->GetPart();
	if (ospFatGSSpecObj == NULL_var)
	{
		//不存在则创建
		int oDiag = 0 ;
		PrtService::CAAGsiCreateGeometricFeatureSets(opiRootContainer,"过程元素",NULL_var,ospFatGSSpecObj,oDiag,1,0);
	}
	//
	//  [3/8/2013 WZ4]
	//
	CATISpecObject_var iospJointGSMTool = NULL_var;
	CATListValCATUnicodeString ilstStrPartsInstName;
	for (int i =1; i <= m_lstSpecPrds.Size(); i++)
	{
		CATIProduct_var spInsPrd = m_lstSpecPrds[i];
		CATIProduct_var spRefPrd = spInsPrd->GetReferenceProduct();

		CATUnicodeString strPrtName;
		strPrtName = spRefPrd->GetPartNumber();
		ilstStrPartsInstName.Append(strPrtName);
	}

	//找到正确的几何图形集放置点模型
	GetPartsJointGSMTool(iospJointGSMTool,ilstStrPartsInstName);
	//
	//把连接零件的PRD指针数组放入该几何图形集，确保关联性
	CATUnicodeString strKey("F_ATTEX_LINK_PRT");
	if (!PrtService::IsExistSpecObjectAttEx(strKey,iospJointGSMTool))
	{
		PrtService::SetSepcObjectAttrEx(m_lstSpecPrds,strKey,iospJointGSMTool);
	}

	//
	//创建几何图形集放置点集合
	int oDiag = 0 ;
	PrtService::CAAGsiCreateGeometricFeatureSets(opiRootContainer,"安装点集合",ospFatGSSpecObj,m_spPointGSMTool,oDiag,0,0);

	//创建基线
	if (m_lstSpecCurves.Size() >= 2 && m_spAssambleCurve==NULL_var)
	{
		m_spAssambleCurve = iospGSMFact->CreateAssemble(m_lstSpecCurves,NULL_var,TRUE);
		PrtService::CAAGsiInsertInProceduralView(m_spAssambleCurve,m_spPointGSMTool);
		PrtService::SetAlias(m_spAssambleCurve,"基线");
		PrtService::SetSpecObjShowAttr(m_spAssambleCurve,"Hide");
		rc = PrtService::ObjectUpdate(m_spAssambleCurve);
		if (FAILED(rc))
		{
			PrtService::ShowDlgNotify("错误提示","所选线集合非连通，请重新选择!");
			spInputCurve->GetFather()->Remove(m_spAssambleCurve);
			m_spPointGSMTool->GetFather()->Remove(m_spPointGSMTool);
			return;
		}
	}
	else if (m_lstSpecCurves.Size() == 1 && m_spAssambleCurve==NULL_var)
	{
		m_spAssambleCurve = m_lstSpecCurves[1];
	}

	//创建平行线
	double dOffsetValue = m_pDlg->_DistanceSpinner->GetValue();
	dOffsetValue *= 1000.0;
	m_dCurveOffsetValue = dOffsetValue;
	//
	CATICkeParm_var spCkeOffset = NULL_var;
	spCkeOffset = PrtService::LocalInstLitteral(&dOffsetValue,1,"Length","Length");
	//
	m_spCurvePar = iospGSMFact->CreateCurvePar(m_spAssambleCurve,m_SpecSurfs,spCkeOffset,FALSE);
	//PrtService::CAAGsiInsertInProceduralView(m_spCurvePar,m_spPointGSMTool);
	PrtService::SetAlias(m_spCurvePar,"排布线");
	PrtService::SetSpecObjShowAttr(m_spCurvePar,"Hide");
	rc = PrtService::ObjectUpdate(m_spCurvePar);
	if (FAILED(rc))
	{
		CATIGSMCurvePar_var spGSMPar = m_spCurvePar;
		spGSMPar->SetInvertDirection(TRUE);
	}
	rc = PrtService::ObjectUpdate(m_spCurvePar);
	if (FAILED(rc))
	{
		PrtService::ShowDlgNotify("错误提示","所选线在所选安装面上无法生成平行线!");
		return;	
	}

	//创建极值点，采用Ratio模式
	double dRatioValue = 0;
	CATICkeParm_var spCkedRatioValue = NULL_var;
	spCkedRatioValue = PrtService::LocalInstLitteral(&dRatioValue,1,"Real","Ratio");
	m_spRefPoint = iospGSMFact->CreatePoint(m_spCurvePar,NULL_var,spCkedRatioValue,FALSE);
	//
	PrtService::CAAGsiInsertInProceduralView(m_spRefPoint,m_spPointGSMTool);

	//	
	return S_OK;	
}

//
//  [3/8/2013 WZ4]
//获取放置点线模型的零件几何图形集
void PrtFstPointsCmd::GetPartsJointGSMTool(CATISpecObject_var &iospJointGSMTool,CATListValCATUnicodeString ilstStrPartsInstName)
{
	//获取所有该几何集下面所有的二级子集
	CATISpecObject_var spLineDefGSMTool = NULL_var;
	PrtService::ObtainGSMTool(m_piDoc,"过程元素",spLineDefGSMTool);
	if (spLineDefGSMTool == NULL_var)
	{
		//获得文档指针
		CATIPrtContainer *opiRootContainer = NULL;
		PrtService::ObtainRootContainer(m_piDoc,opiRootContainer);
		//不存在则创建
		int oDiag = 0 ;
		PrtService::CAAGsiCreateGeometricFeatureSets(opiRootContainer,"过程元素",NULL_var,spLineDefGSMTool,oDiag,1,0);
	}
	CATListValCATISpecObject_var iolstspFoundResult;
	PrtService::SearchALLSonFromRootGSMTool(spLineDefGSMTool,iolstspFoundResult);

	//解析这些几何图形集的名称，找到匹配名字的那个
	CATBoolean IsGetTheOne = FALSE;
	for (int i=1; i <= iolstspFoundResult.Size(); i++)
	{
		CATListValCATUnicodeString lststrResult;
		CATUnicodeString strAlias = PrtService::GetAlias(iolstspFoundResult[i]);
		CHandleString::StringToVector(strAlias,"|",lststrResult);

		//先判断个数
		if (lststrResult.Size() == ilstStrPartsInstName.Size())
		{
			//
			CATListValCATUnicodeString lstIsOrNot;
			//
			for (int j = 1; j <= lststrResult.Size(); j ++)
			{
				for (int n = 1; n <= ilstStrPartsInstName.Size(); n ++ )
				{
					if (lststrResult[j] == ilstStrPartsInstName[n])
					{
						lstIsOrNot.Append("1");
						break;
					}
					//
					if (n == ilstStrPartsInstName.Size())
					{
						lstIsOrNot.Append("0");
					}
				}
			}
			//
			CATBoolean IsRight=TRUE;
			for (int n=1; n<=lstIsOrNot.Size(); n++)
			{
				if (lstIsOrNot[n]=="0")
				{
					IsRight = FALSE;
					break;
				}
			}
			//
			if (IsRight == TRUE)
			{
				iospJointGSMTool = iolstspFoundResult[i];
				IsGetTheOne = TRUE;
				break;
			}
		} 
		else //直接跳过
		{
			continue;
		}
	}

	//所有查询后未发现需要的信息时，自动根据输入创建一个几何图形集
	if (IsGetTheOne == FALSE)
	{
		//创建点线模型几何图形集
		CATUnicodeString strPartsJointName;
		for (int i=1; i <= ilstStrPartsInstName.Size(); i++)
		{
			strPartsJointName += ilstStrPartsInstName[i];
			if (i != ilstStrPartsInstName.Size())
			{
				strPartsJointName += "|";
			}
		}
		//不存在则创建
		CATIPrtContainer *opiRootContainer = NULL;
		PrtService::ObtainRootContainer(m_piDoc,opiRootContainer);
		int oDiag = 0 ;
		PrtService::CAAGsiCreateGeometricFeatureSets(opiRootContainer,strPartsJointName,spLineDefGSMTool,iospJointGSMTool,oDiag,0,0);
	}
}
//

void PrtFstPointsCmd::CreatePoints()
{
	/*
	//获得状态的所有值
	//如果选择 间距模式
	double odGapValue = 0;
	odGapValue = m_pDlg->_PointDistSpinner->GetValue();
	odGapValue *= 1000.0;
	//
	//如果选择 点数模式
	double odNumValue = 0;
	odNumValue = m_pDlg->_NumSpinner->GetValue();
	//
	//创建偏移线
	double dOffsetValue = m_pDlg->_DistanceSpinner->GetValue();
	dOffsetValue *= 1000.0;
	//
	double dType;
	if (m_pDlg->_NumPointRB->GetState() == CATDlgCheck)
	{
		dType=2;
	}
	else
	{
		dType=1;
	}
	//
	CATBoolean IsChangedValue = FALSE;
	if (odGapValue!=m_dPointDistance || odNumValue!=m_dPointsCount || dOffsetValue!=m_dCurveOffsetValue || dType!=m_dType)
	{
		IsChangedValue=TRUE;
		//
		m_dCurveOffsetValue = dOffsetValue;
		m_dPointsCount = odNumValue;
		m_dPointDistance = odGapValue;
		m_dType=dType;
	}

	//
	if (m_spPointGSMTool != NULL_var && m_spCurvePar != NULL_var && m_alstSpecPoint.Size()!=0 && IsChangedValue)
	{
		//获得文档指针
		CATDocument * pDoc = PrtService::GetPrtDocument();
		CATIGSMFactory_var iospGSMFact = NULL_var;
		PrtService::GetGSMFactory(pDoc,iospGSMFact);
		//
		for (int i=1; i<=m_alstSpecPoint.Size(); i++)
		{
			m_spPointGSMTool->Remove(m_alstSpecPoint[i]);
		}
		m_alstSpecPoint.RemoveAll();
		//
		//
		CATICkeParm_var spCkeOffset = NULL_var;
		spCkeOffset = PrtService::LocalInstLitteral(&dOffsetValue,1,"Length","Length");
		//
		//
		CATIGSMCurvePar_var spGSMCurvePar = m_spCurvePar;
		spGSMCurvePar->SetCurveParValue(spCkeOffset);

		//
		//获得交付设置的参数
		if (m_pDlg->_NumPointRB->GetState() == CATDlgCheck)
		{
			//如果选择 点数模式
			double odNumValue = 0;
			odNumValue = m_pDlg->_NumSpinner->GetValue();
			//
			if (odNumValue == 0)
			{
				PrtService::ShowDlgNotify("错误提示","所设置点数不能为0!");
				//
				m_spPointGSMTool->GetFather()->Remove(m_spPointGSMTool);
				m_spPointGSMTool=NULL_var;
				m_spCurvePar=NULL_var;
				//
				return;	
			}
			//
			m_dPointsCount=odNumValue;
			//获得长度值
			CATIMeasurableCurve_var spMeasCurve = NULL_var;
			spMeasCurve = m_spCurvePar;
			if (spMeasCurve != NULL_var)
			{
				double dCrvLength = 0;
				spMeasCurve->GetLength(dCrvLength);
				//
				double dDistanceV = dCrvLength/(odNumValue+1);
				//
				CATBoolean pointErrFlag = FALSE;
				//
				for (int i=1; i <= odNumValue; i ++)
				{
					double dDistValues = i*dDistanceV;
					CATICkeParm_var spCkedDistanceV = NULL_var;
					spCkedDistanceV = PrtService::LocalInstLitteral(&dDistValues,1,"Length","Length");
					//
					CATISpecObject_var spPoint = iospGSMFact->CreatePoint(m_spCurvePar,NULL_var,spCkedDistanceV,CATGSMSameOrientation);
					PrtService::CAAGsiInsertInProceduralView(spPoint,m_spPointGSMTool);
					//
					HRESULT rc = PrtService::ObjectUpdate(spPoint);
					if (FAILED(rc))
					{
						spPoint->GetFather()->Remove(spPoint);
						spPoint=NULL_var;
						pointErrFlag = TRUE;
					}
					else
					{
						m_alstSpecPoint.Append(spPoint);
					}
				}
				//
				if (pointErrFlag == TRUE)
				{
					PrtService::ShowDlgNotify("错误提示","所选线不能为闭合曲线，无法生存安装点，请重新选择!");
					//
					m_spPointGSMTool->GetFather()->Remove(m_spPointGSMTool);
					m_spPointGSMTool=NULL_var;
					m_spCurvePar=NULL_var;
					//
					return;
				}

			}
		} 
		else
		{
			//如果选择 间距模式
			double odGapValue = 0;
			odGapValue = m_pDlg->_PointDistSpinner->GetValue();
			odGapValue *= 1000.0;
			//
			if (odGapValue == 0)
			{
				PrtService::ShowDlgNotify("错误提示","所设置点间隙值不能为0!");
				//
				m_spPointGSMTool->GetFather()->Remove(m_spPointGSMTool);
				m_spPointGSMTool=NULL_var;
				m_spCurvePar=NULL_var;
				return;	
			}
			//
			m_dPointDistance=odGapValue;
			//获得长度值
			CATIMeasurableCurve_var spMeasCurve = NULL_var;
			spMeasCurve = m_spCurvePar;
			if (spMeasCurve != NULL_var)
			{
				double dCrvLength = 0;
				spMeasCurve->GetLength(dCrvLength);
				//
				double odNumValue = (int)(dCrvLength/odGapValue)-1;
				//
				CATBoolean pointErrFlag = FALSE;
				//
				for (int i=1; i <= odNumValue; i ++)
				{
					double dDistValues = i*odGapValue;
					CATICkeParm_var spCkedDistanceV = NULL_var;
					spCkedDistanceV = PrtService::LocalInstLitteral(&dDistValues,1,"Length","Length");
					//
					CATISpecObject_var spPoint = iospGSMFact->CreatePoint(m_spCurvePar,NULL_var,spCkedDistanceV,CATGSMSameOrientation);
					PrtService::CAAGsiInsertInProceduralView(spPoint,m_spPointGSMTool);
					//
					HRESULT rc = PrtService::ObjectUpdate(spPoint);
					if (FAILED(rc))
					{
						spPoint->GetFather()->Remove(spPoint);
						spPoint=NULL_var;
						pointErrFlag = TRUE;
					}
					else
					{
						m_alstSpecPoint.Append(spPoint);
					}
				}
				//
				if (pointErrFlag == TRUE)
				{
					PrtService::ShowDlgNotify("错误提示","所选线不能为闭合曲线，无法生存安装点，请重新选择!");
					//
					m_spPointGSMTool->GetFather()->Remove(m_spPointGSMTool);
					m_spPointGSMTool=NULL_var;
					m_spCurvePar=NULL_var;
					return;
				}
			}
		}
	}

	//
	if (m_spPointGSMTool == NULL_var && m_spCurvePar == NULL_var && m_alstSpecPoint.Size()==0)
	{
		//
		//
		HRESULT rc = S_OK;
		//获得文档指针
		CATDocument * pDoc = PrtService::GetPrtDocument();
		CATIGSMFactory_var iospGSMFact = NULL_var;
		PrtService::GetGSMFactory(pDoc,iospGSMFact);

		//创建几何图形集
		CATISpecObject_var ospFatGSSpecObj = NULL_var;
		PrtService::ObtainGSMTool(pDoc,"过程元素",ospFatGSSpecObj);
		CATIPrtContainer *opiRootContainer = NULL;
		PrtService::ObtainRootContainer(pDoc,opiRootContainer);
		//获得part
		CATISpecObject_var spPart = opiRootContainer->GetPart();
		if (ospFatGSSpecObj == NULL_var)
		{
			//不存在则创建
			int oDiag = 0 ;
			PrtService::CAAGsiCreateGeometricFeatureSets(opiRootContainer,"过程元素",NULL_var,ospFatGSSpecObj,oDiag,1,0);
		}
		//创建几何图形集放置点集合
		int oDiag = 0 ;
		PrtService::CAAGsiCreateGeometricFeatureSets(opiRootContainer,"安装点集合",ospFatGSSpecObj,m_spPointGSMTool,oDiag,0,0);

		//创建偏移线
		CATISpecObject_var spInputCurve = NULL_var;
		if (m_lstSpecCurves.Size() >= 2)
		{
			spInputCurve = iospGSMFact->CreateAssemble(m_lstSpecCurves,NULL_var,TRUE);
			PrtService::CAAGsiInsertInProceduralView(spInputCurve,m_spPointGSMTool);
			PrtService::SetAlias(spInputCurve,"基线");
			PrtService::SetSpecObjShowAttr(spInputCurve,"Hide");
			rc = PrtService::ObjectUpdate(spInputCurve);
			if (FAILED(rc))
			{
				PrtService::ShowDlgNotify("错误提示","所选线集合非连通，请重新选择!");
				spInputCurve->GetFather()->Remove(spInputCurve);
				m_spPointGSMTool->GetFather()->Remove(m_spPointGSMTool);
				return;
			}
		}
		else if (m_lstSpecCurves.Size() == 1)
		{
			spInputCurve = m_lstSpecCurves[1];
		}

		//创建偏移线
		double dOffsetValue = m_pDlg->_DistanceSpinner->GetValue();
		dOffsetValue *= 1000.0;
		m_dCurveOffsetValue = dOffsetValue;
		//
		CATICkeParm_var spCkeOffset = NULL_var;
		spCkeOffset = PrtService::LocalInstLitteral(&dOffsetValue,1,"Length","Length");
		//
		m_spCurvePar = iospGSMFact->CreateCurvePar(spInputCurve,m_SpecSurfs,spCkeOffset,FALSE);
		PrtService::CAAGsiInsertInProceduralView(m_spCurvePar,m_spPointGSMTool);
		PrtService::SetAlias(m_spCurvePar,"排布线");
		PrtService::SetSpecObjShowAttr(m_spCurvePar,"Hide");
		rc = PrtService::ObjectUpdate(m_spCurvePar);
		if (FAILED(rc))
		{
			CATIGSMCurvePar_var spGSMPar = m_spCurvePar;
			spGSMPar->SetInvertDirection(TRUE);
		}
		rc = PrtService::ObjectUpdate(m_spCurvePar);
		if (FAILED(rc))
		{
			PrtService::ShowDlgNotify("错误提示","所选线在算选安装面上无法生成平行线!");
			m_spCurvePar->GetFather()->Remove(m_spCurvePar);
			m_spPointGSMTool->GetFather()->Remove(m_spPointGSMTool);
			return;	
		}

		//获得交付设置的参数
		if (m_pDlg->_NumPointRB->GetState() == CATDlgCheck)
		{
			//如果选择 点数模式
			double odNumValue = 0;
			odNumValue = m_pDlg->_NumSpinner->GetValue();
			//
			if (odNumValue == 0)
			{
				PrtService::ShowDlgNotify("错误提示","所设置点数不能为0!");
				//
				m_spPointGSMTool->GetFather()->Remove(m_spPointGSMTool);
				m_spPointGSMTool=NULL_var;
				m_spCurvePar=NULL_var;
				//
				return;	
			}
			//
			m_dPointsCount=odNumValue;
			//获得长度值
			CATIMeasurableCurve_var spMeasCurve = NULL_var;
			spMeasCurve = m_spCurvePar;
			if (spMeasCurve != NULL_var)
			{
				double dCrvLength = 0;
				spMeasCurve->GetLength(dCrvLength);
				//
				double dDistanceV = dCrvLength/(odNumValue+1);
				//
				CATBoolean pointErrFlag = FALSE;
				//
				for (int i=1; i <= odNumValue; i ++)
				{
					double dDistValues = i*dDistanceV;
					CATICkeParm_var spCkedDistanceV = NULL_var;
					spCkedDistanceV = PrtService::LocalInstLitteral(&dDistValues,1,"Length","Length");
					//
					CATISpecObject_var spPoint = iospGSMFact->CreatePoint(m_spCurvePar,NULL_var,spCkedDistanceV,CATGSMSameOrientation);
					PrtService::CAAGsiInsertInProceduralView(spPoint,m_spPointGSMTool);
					//
					rc = PrtService::ObjectUpdate(spPoint);
					if (FAILED(rc))
					{
						spPoint->GetFather()->Remove(spPoint);
						spPoint=NULL_var;
						pointErrFlag = TRUE;
					}
					else
					{
						m_alstSpecPoint.Append(spPoint);
					}
				}
				//
				if (pointErrFlag == TRUE)
				{
					PrtService::ShowDlgNotify("错误提示","所选线不能为闭合曲线，无法生存安装点，请重新选择!");
					//
					//
					m_spPointGSMTool->GetFather()->Remove(m_spPointGSMTool);
					m_spPointGSMTool=NULL_var;
					m_spCurvePar=NULL_var;
					//
					return;
				}

			}
		} 
		else
		{
			//如果选择 间距模式
			double odGapValue = 0;
			odGapValue = m_pDlg->_PointDistSpinner->GetValue();
			odGapValue *= 1000.0;
			//
			if (odGapValue == 0)
			{
				PrtService::ShowDlgNotify("错误提示","所设置点间隙值不能为0!");
				//
				m_spPointGSMTool->GetFather()->Remove(m_spPointGSMTool);
				m_spPointGSMTool=NULL_var;
				m_spCurvePar=NULL_var;

				return;	
			}
			//
			m_dPointDistance=odGapValue;
			//获得长度值
			CATIMeasurableCurve_var spMeasCurve = NULL_var;
			spMeasCurve = m_spCurvePar;
			if (spMeasCurve != NULL_var)
			{
				double dCrvLength = 0;
				spMeasCurve->GetLength(dCrvLength);
				//
				double odNumValue = (int)(dCrvLength/odGapValue)-1;
				//
				CATBoolean pointErrFlag = FALSE;
				//
				for (int i=1; i <= odNumValue; i ++)
				{
					double dDistValues = i*odGapValue;
					CATICkeParm_var spCkedDistanceV = NULL_var;
					spCkedDistanceV = PrtService::LocalInstLitteral(&dDistValues,1,"Length","Length");
					//
					CATISpecObject_var spPoint = iospGSMFact->CreatePoint(m_spCurvePar,NULL_var,spCkedDistanceV,CATGSMSameOrientation);
					PrtService::CAAGsiInsertInProceduralView(spPoint,m_spPointGSMTool);
					//
					rc = PrtService::ObjectUpdate(spPoint);
					if (FAILED(rc))
					{
						spPoint->GetFather()->Remove(spPoint);
						spPoint=NULL_var;
						pointErrFlag = TRUE;
					}
					else
					{
						m_alstSpecPoint.Append(spPoint);
					}
				}
				//
				if (pointErrFlag == TRUE)
				{
					PrtService::ShowDlgNotify("错误提示","所选线不能为闭合曲线，无法生存安装点，请重新选择!");
					//
					m_spPointGSMTool->GetFather()->Remove(m_spPointGSMTool);
					m_spPointGSMTool=NULL_var;
					m_spCurvePar=NULL_var;
					//
					return;
				}
			}

		}
		PrtService::ObjectUpdate(spPart);

		//隐藏线
		for (int i = 1; i <= m_lstSpecCurves.Size(); i++)
		{
			PrtService::SetSpecObjShowAttr(m_lstSpecCurves[i],"Hide");
		}

		//隐藏面
		PrtService::SetSpecObjShowAttr(m_SpecSurfs,"Hide");
	}
	*/
}
